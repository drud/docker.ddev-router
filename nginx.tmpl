{{ $CurrentContainer := where $ "ID" .Docker.CurrentContainerID | first }}

{{ define "upstream" }}
    {{ if .Address }}
        {{/* If we got the containers from swarm and this container's port is published to host, use host IP:PORT */}}
        {{ if and .Container.Node.ID .Address.HostPort }}
            # {{ .Container.Node.Name }}/{{ .Container.Name }}
            server {{ .Container.Node.Address.IP }}:{{ .Address.HostPort }};
        {{/* If there is no swarm node or the port is not published on host, use container's IP:PORT */}}
        {{ else if .Network }}
            # {{ .Container.Name }}
            server {{ .Network.IP }}:{{ .Address.Port }};
        {{ end }}
    {{ else if .Network }}
        # {{ .Container.Name }}
        server {{ .Network.IP }} down;
    {{ end }}
{{ end }}

# If we receive X-Forwarded-Proto, pass it through; otherwise, pass along the
# scheme used to connect to this server
map $http_x_forwarded_proto $proxy_x_forwarded_proto {
  default $http_x_forwarded_proto;
  ''      $scheme;
}

# If we receive Upgrade, set Connection to "upgrade"; otherwise, delete any
# Connection header that may have been passed to this server
map $http_upgrade $proxy_connection {
  default upgrade;
  '' close;
}

gzip_types text/plain text/css application/javascript application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;

log_format vhost '$host $remote_addr - $remote_user [$time_local] '
                 '"$request" $status $body_bytes_sent '
                 '"$http_referer" "$http_user_agent"';

access_log off;

{{ if (exists "/etc/nginx/proxy.conf") }}
include /etc/nginx/proxy.conf;
{{ else }}
# HTTP 1.1 support
proxy_http_version 1.1;
proxy_buffering off;
proxy_set_header Host $http_host;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $proxy_connection;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header X-Forwarded-Proto $proxy_x_forwarded_proto;

# Mitigate httpoxy attack (see README for details)
proxy_set_header Proxy "";
{{ end }}

server {
    server_name _; # This is just an invalid value which will never trigger on a real hostname.
    listen 80;
    access_log /var/log/nginx/access.log vhost;

    return 503;

    error_page 503 @noupstream;
    location @noupstream {
        rewrite ^(.*)$ /503.html break;
        root /app;
    }

}


{{ if (and (exists "/etc/nginx/certs/default.crt") (exists "/etc/nginx/certs/default.key")) }}
server {
    server_name _; # This is just an invalid value which will never trigger on a real hostname.
    listen 443 ssl http2;
    access_log /var/log/nginx/access.log vhost;
    return 503;

    ssl_session_tickets off;
    ssl_certificate /etc/nginx/certs/default.crt;
    ssl_certificate_key /etc/nginx/certs/default.key;
}
{{ end }}

{{ range $host, $containers := groupByMulti $ "Env.VIRTUAL_HOST" "," }}

{{/* If host is defined as hostname:port, port will be used as the listen port instead of 80 */}}
{{ $host_port := split $host ":" }}
{{ $hostname := first $host_port }}
{{ $ext_port := last $host_port }}
{{/* if hostname and ext_port match, there was no ":", so fallback to port 80 */}}
{{ $ext_port := when (eq $hostname $ext_port) "80" $ext_port}}
{{ $host := $hostname }}

{{ range $container := $containers }}
    {{ $ports := coalesce $container.Env.HTTP_EXPOSE "80" }}
    {{ $ports := split $ports "," }}
    {{ range $port := $ports }}
    {{/* process values in hostPort:containerPort docker format, containerPort is upstream */}}
    {{ $container_ports := split $port ":" }}
    {{ $upstream_port := last $container_ports }}

    upstream {{ $container.Name }}-{{ $upstream_port }} {
        {{ $addrLen := len $container.Addresses }}

        {{ range $knownNetwork := $CurrentContainer.Networks }}
            {{ range $containerNetwork := $container.Networks }}
                {{ if eq $knownNetwork.Name $containerNetwork.Name }}
                ## Can connect with "{{ $containerNetwork.Name }}" network
                {{/* If only 1 port exposed, use that */}}
                {{ if eq $addrLen 1 }}
                {{ $address := index $container.Addresses 0 }}
                {{ template "upstream" (dict "Container" $container "Address" $address "Network" $containerNetwork) }}
                {{/* If more than one port exposed, use the one matching HTTP_EXPOSE env var, falling back to standard web port 80 */}}
                {{ else }}
                {{ $address := where $container.Addresses "Port" $upstream_port | first }}
                {{ template "upstream" (dict "Container" $container "Address" $address "Network" $containerNetwork) }}
                {{ end }}
    }
{{ end }}
{{ end }}
{{ end }}
{{ end }}
{{ end }}


{{ $default_host := or ($.Env.DEFAULT_HOST) "" }}
{{ $default_server := index (dict $host "" $default_host "default_server") $host }}

{{/* Get the VIRTUAL_PROTO defined by containers w/ the same vhost, falling back to "http" */}}
{{ $proto := or (first (groupByKeys $containers "Env.VIRTUAL_PROTO")) "http" }}

{{/* Get the HTTPS_METHOD defined by containers w/ the same vhost, falling back to "redirect" */}}
{{ $https_method := or (first (groupByKeys $containers "Env.HTTPS_METHOD")) "redirect" }}

{{/* Get the first cert name defined by containers w/ the same vhost */}}
{{ $certName := (first (groupByKeys $containers "Env.CERT_NAME")) }}

{{/* Get the best matching cert  by name for the vhost. */}}
{{ $vhostCert := (closest (dir "/etc/nginx/certs") (printf "%s.crt" $host))}}

{{/* vhostCert is actually a filename so remove any suffixes since they are added later */}}
{{ $vhostCert := trimSuffix ".crt" $vhostCert }}
{{ $vhostCert := trimSuffix ".key" $vhostCert }}

{{/* Use the cert specified on the container or fallback to the best vhost match */}}
{{ $cert := (coalesce $certName $vhostCert) }}

{{ $is_https := (and (ne $cert "") (exists (printf "/etc/nginx/certs/%s.crt" $cert)) (exists (printf "/etc/nginx/certs/%s.key" $cert))) }}

{{/* Get the container name defined by containers w/ the same vhost */}}
{{ range $host, $containers := groupByMulti $ "Env.VIRTUAL_HOST" "," }}
    {{ range $container := whereExist $containers "Env.HTTP_EXPOSE" }}
        {{/* Get the HTTP_EXPOSE defined by containers w/ the same vhost, falling back to port 80 */}}
        {{ $ports := coalesce $container.Env.HTTP_EXPOSE "80" }}
        {{ $ports := split $ports "," }}
        {{ range $port := $ports }}
        {{/* process values in hostPort:containerPort docker format */}}
        {{ $container_ports := split $port ":" }}
        {{/* hostPort is port to listen on */}}
        {{ $listen_port := first $container_ports }}
        {{/* containerPort is upstream */}}
        {{ $upstream_port := last $container_ports }}
        server {
            server_name {{ $host }};
            listen {{ $listen_port }} {{ $default_server }};
            access_log /var/log/nginx/access.log vhost;
            location @brokenupstream {
                rewrite ^(.*)$ /502.html break;
                root /app;
            }


            {{ if (exists (printf "/etc/nginx/vhost.d/%s" $host)) }}
            include {{ printf "/etc/nginx/vhost.d/%s" $host }};
            {{ else if (exists "/etc/nginx/vhost.d/default") }}
            include /etc/nginx/vhost.d/default;
            {{ end }}

            location / {
                {{ if eq $proto "uwsgi" }}
                include uwsgi_params;
                uwsgi_pass {{ trim $proto }}://{{ trim $container.Name }}-{{ trim $upstream_port }};
                {{ else }}
                proxy_pass {{ trim $proto }}://{{ trim $container.Name }}-{{ trim $upstream_port }};
                error_page 502 @brokenupstream;
                {{ end }}
                {{ if (exists (printf "/etc/nginx/htpasswd/%s" $host)) }}
                auth_basic	"Restricted {{ $host }}";
                auth_basic_user_file	{{ (printf "/etc/nginx/htpasswd/%s" $host) }};
                {{ end }}
                {{ if (exists (printf "/etc/nginx/vhost.d/%s_location" $host)) }}
                include {{ printf "/etc/nginx/vhost.d/%s_location" $host}};
                {{ else if (exists "/etc/nginx/vhost.d/default_location") }}
                include /etc/nginx/vhost.d/default_location;
                {{ end }}
            }
        }
        {{ end }}
    {{ end }}
{{ end }}
{{ end }}
